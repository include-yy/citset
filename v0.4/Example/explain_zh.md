# 埃拉托斯特尼筛法

上[维基](https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95)看详细解释,维基上不了就安全上网或者vpn，再不济上百毒。

![avatar](https://github.com/include-yy/Graph/blob/master/citset/Sieve_of_Eratosthenes_animation.gif)

## 引自维基

埃拉托斯特尼筛法（希腊语：κόσκινον Ἐρατοσθένους，英语：sieve of Eratosthenes ），简称埃氏筛，也称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的素数。

所使用的原理是从 2 开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。

埃拉托斯特尼筛法是列出所有小素数最有效的方法之一，其名字来自于古希腊数学家埃拉托斯特尼，并且被描述在另一位古希腊数学家尼科马库斯所著的《算术入门》中。

## 个人理解

假设需要寻找 N 一下的素数，可以使用一个`int`数组，i 为素数则 a[i] = 1, 否则 a[i] = 0。首先将数组 a 的所有元素设为 1，并将 a[0] 和 a[1] 设为 0，它们不是素数。接着从 2 开始， 2 既然是素数，那么 4，6，8，10，...... 就都不是素数，所以把 a[4], a[6], a[8], a[10]......都设为 0。在 N 以下的 2 的倍数被筛完了之后，向下寻找使得 a[i] 不为 0 的 i，再对 i 进行和 2 一样的操作，如此反复，直到筛完为止。

## 一些改进

既然只需要 0 和 1 来表示是否为素数，那么使用`int`也太浪费内存了，用`char`稍微好一点，但还是相当于用了本来只需要的八倍。`_Bool`看起来是个布尔值，其实还是一个字节，所以要操纵一个位的状态，还是只能自己写。

## 我的经历

在[projecteular](https://projecteuler.net/problem=10)上刷题的时候遇到了求素数和的问题，要求两百万以下，我不动脑子的直接进行素性判断。
```
int isPrime(int n)
{
    int i;
    for(i = 2;i < n;i ++)
    {
        if(n % i == 0)
          break;
    }
    if(i == n)
        return 1;
    else
        return 0;
}
```
就这样一个一个的找，用了差不多五分钟，写完后到讨论区看了下别人的代码，学到了。

## 和 C++ 的比较
这个库的第一版，第二版，第三版，我在我的电脑上测试的时候，都比 C++ 写法慢个三倍左右。第四版进行了相应的改进，速度上比 C++ 版的居然还快了一丢丢。哈哈。


